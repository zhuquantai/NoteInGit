
call
mms
message
sim

状态数据的保存
显示数据的封装（考虑到数据扩充的问题）
代码结构的优化
显示层与业务层的分离
可以考虑将状态变量到提取为成员变量，在代码体中尽量不写死变量，以提高重用性
对于某些重复性到工作可以抽取为方法

implement Serializable or Parcelable 才能通过Intent传递对象
CheckBox焦点优先级高于ListViewItem,使用android:descendantFocusability="blocksDescendants"

# push source to gerrit
push command: git push ssh://quantai.zhu@10.92.32.10:29418/innovateapp/gudong HEAD:refs/for/jrdhz_02

# MyNote App总结
# 一，软件结构
- MainActivity
    - ViewPage
        - MyPageAdapter
        - layout
        - data:
            - EditFragment
                - layout
            - DisplayFragment
                - ListView
                    - NoteAdapter extends BaseAdapter
                    - noteBeans
                    - layout
            - ManagerFragment
                    - ManagerAdapter extends BaseAdapter
                    - noteBeans
                    - layout
    - layout
- NoteActivity
- Widget
    - layout
    - appwidget-provider
    - NoteWidgetProvider extends AppWidgetProvider

# 二，使用到的控件
### ViewPage
### Fragment
### ListView
### BroadCastReceiver
### Widget
### SQLite

# 三，总结
可以在MainActivity中写查询数据库的方法，避免在其他类中冗余操作
-------------------------------------------------------------------------
在Widget中无法直接starActivity(Intent)，通过一个BroadcastReceiver中转
-------------------------------------------------------------------------
ListView的Adapter中有时notifyDataSetChanged无法实时更新数据，需要先强制setData
```
//if data has changed ,notify List View to update
public void notifyDataUpdate() {
    if (managerAdapter != null) {
        beans = getBeans();
        managerAdapter.setBeans(beans);
        managerAdapter.notifyDataSetChanged();
    }
}
```
-------------------------------------------------------------------------
ListView 注意事项：
可以在ListView的Item的子View中再添加点击监听
```
@Override
public View getView(final int position, View convertView, ViewGroup parent) {
    if (convertView == null) {
        convertView = View.inflate(context, R.layout.listview_item, null);
    }
    TextView titleView= (TextView) convertView.findViewById(R.id.tv_main_title);
    TextView descView= (TextView) convertView.findViewById(R.id.tv_main_desc);
    ImageView likeView= (ImageView) convertView.findViewById(R.id.iv_main_like);

    final Month month = (Month) getItem(position);
    titleView.setText(month.getName());
    descView.setText(month.getDesc());
    if (month.isLike()) {
        likeView.setImageResource(android.R.drawable.star_big_on);
    }else {
        likeView.setImageResource(android.R.drawable.star_big_off);
    }
    likeView.setOnClickListener(new View.OnClickListener(){

        @Override
        public void onClick(View v) {
            Log.e("TAG", month.toString());
            if (month.isLike()) {
                month.setLike(false);
            }else {
                month.setLike(true);
            }
            notifyDataSetChanged();
        }

    });
    return convertView;
}
```





# AppList总结：
# 程序设计：
### 一，变量设定：
- 两个List<HashSet>分别存放系统应用和个人应用
用以在两个ListView中显示数据
用以在存储当前Item是否被选中
- 两个Int分别存放当前系统应用和个人应用的选择个数
用以判断是否全选
### 二，程序流程
1. onCreate方法中
    1. 加载布局
    2. 初始化TabHost
    3. 创建loadPackageTask extends AsyncTask对象
        1. 构造器中创建ProgressDialog提示加载
        2. 调用 doInBackground方法
            1. loadPackageList 加载系统包信息
                1. 获取所有应用包信息
                2. 获取存储的被选择到包信息
                3. 将存储信息录入所有应用包信息，并更新应用选择个数
                到此，第一次进入APP要显示的信息项已经加载完毕
            2. 包信息进行字母排序（使用Comparator接口） sortPackageList
            3. 取消ProgressDialog显示
        3. onPostExecute方法中调用
            1. 初始化UI界面 initUiComponents
                1. ListView + SimpleAdapter 显示
                2. ListView 添加点击监听
                    1. 得到点击到数据
                    2. 设定选择状态
                    3. 判定当前显示的Tab
                    4. 更新对应Tab选择个数
                    5. 更新对应TabListView显示
                    6. 更新对应Tab的Button显示信息
                3. 初始化按键 initCmdBtns
                    1. "保存"按钮设置监听
                        1. 保存信息 saveSelectedAppsList
                            1. 得到被选择项的标识信息 Set<String>
                            2. 使用不同的储存方式储存到本地 saveInFile(selectAppsList)
                    2. "全选"按钮设置监听
                        1. 全选或者全部取消 toggleAllListItemSelection
                            1. 判断当前显示的Tab
                            2. 判断是否已经全选
                            3. 如果全选，取消选择；如果没全选，设定全选
                            4. 更新数据(Count,ListView,Button)

# 注意到点
### 存储Object
Object obj = (new ObjectInputStream(mContext.openFileInput(SAVE_FILE_NAME))).readObject();
--------------------------------------------------------------------------------------
# SimpleAdapter设定ViewBinder
###### 说明
- 对于SimpleAdapter的数据绑定，有一个期待绑定值：
- 对于View实现了Checkable(如CheckBox),期待值为boolean
- 对于TextView，期待值为String
- 对于ImageView，期待值为资源id(或Bitmap?)
- 如果没有期待的绑定值会发生: IllegalStateException
- 所以有时需要给SimpleAdapter设定ViewBinder

- setViewValue返回值为true表示绑定完成，不再采用系统默认绑定
- 返回值为false表示采用系统默认绑定

###### API
```
public void setViewBinder (SimpleAdapter.ViewBinder viewBinder)
```

###### 实例
```
SimpleAdapter adapter = new SimpleAdapter(this, dataList, R.layout.package_list_layout,
                VIEW_TEXT_ARRAY, VIEW_RES_ID_ARRAY);
adapter.setViewBinder(new ViewBinder() {
    @Override
    public boolean setViewValue(View view, Object data, String textRepresentation) {
        if ((view instanceof ImageView) && (data instanceof Drawable)) {
            ImageView iv = (ImageView) view;
            //iv.setImageBitmap((Bitmap) data);
            iv.setImageDrawable((Drawable) data);
            return true;
        }
        return false;
    }
});
```
--------------------------------------------------------------------------------------
尽量做到代码体中无显式字符串
当布局控件较多时，可分类依次布局，如先写显示，再写监听，将他们分别封装到方法中
一个功能需要哪些输入变量，哪些输出变量，哪些中间变量，以怎样到逻辑操作，需要在写之前好好分析，20%的时间花费是值得的
--------------------------------------------------------------------------------------



# FruitApp总结：
1. 对于Activity之间无太多交互的，如只传递一个Intent,可以一个页面一个页面的写；
如果逻辑性比较强的可以按照逻辑思路写
2. 状态数据的保存，在这里使用了成员变量
3. 显示数据的封装（考虑到数据扩充的问题），在这里使用了FruitPage封装要显示的数据
4. 代码结构的优化，监听器与主业务代码分离，使用成员变量方法以提高阅读性
5. 显示层与业务层的分离，可以考虑将状态变量到提取为成员变量，在代码体中尽量不写死变量，以提高重用性
6. 对于某些重复性的工作、业务性较强的代码可以抽取为方法
7. 先写业务逻辑，再写业务实现？，熟练之后可以考虑


# FragmentApp总结：
- 广播可以在Manifest中注册action（不需要app的启动）,也可以在Activity中注册action（和Activity同生死）
- Manifest不仅是App的配置清单，当配置了Intent-Filter之后，也注册到系统
- 一个Fragment的子类包含一个布局，在Activity layout文件中连接声明子类，自动生成一个布局插入
- 使用Fragment的两种方式：
    1. 可以在Activitylayout文件中划分一块空间为FramLayout，
然后用Fragment的子类去replace，可以达到画面切换的效果.
    2. 可以在布局中直接指定一个Fragment对象

# vim install 
if a issue occur when install vim ,this may help you:
sudo apt-get purge vim-common
sudo apt-get update
sudo apt-get upgrade
sudo apt-get install vim
