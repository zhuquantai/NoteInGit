### 一、说明
1. native 是用做java 和其他语言（如c++）进行协作时使用的，也就是native 后的函数的实现不是用java写的。
native的意思就是通知操作系统， 这个函数你必须给我实现，因为我要使用。 所以native关键字的函数都是操作系统实现的， java只能调用。
2. java是跨平台的语言，既然是跨了平台，所付出的代价就是牺牲一些对底层的控制，而java要实现对底层的控制，就需要一些其他语言的帮助，这个就是native的作用了
### 二、一个例子
###### Step1: 编写一个使用native关键字的java程序
HelloWorld.java
```
public class HelloWorld {
    static {
        System.loadLibrary("user");
    }
	//使用native修饰的接口(这个类不用使用abstract修饰)
    public native static void showHello();

    public static void main(String[] args) {
        HelloWorld helloWorld = new HelloWorld();
        helloWorld.showHello();
    }
}
```
###### Step2: 编译HelloWorld.java 得到HelloWorld.java
```
javac HelloWorld.java
```
###### Step3: 生成头文件HelloWorld.h
```
javah HelloWorld
```
HelloWorld.h
```
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class HelloWorld */

#ifndef _Included_HelloWorld
#define _Included_HelloWorld
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     HelloWorld
 * Method:    showHello
 * Signature: ()V
 */
//系统生成的接口名，我们需要实现这个函数
JNIEXPORT void JNICALL Java_HelloWorld_showHello (JNIEnv *, jclass);

#ifdef __cplusplus
}
#endif
#endif
```
###### Step4: 实现头文件中的函数
user.c
```
#include <jni.h>
#include <stdio.h>
#include "HelloWorld.h"

/*
 * Class:     HelloWorld
 * Method:    showHello
 * Signature: ()V
 */
//实现接口的方法
JNIEXPORT void JNICALL Java_HelloWorld_showHello (JNIEnv *env, jclass jc){
	printf("HelloWorld!");  
}
```
###### Step5: 编译打包
```
gcc -fPIC -D_PEENTRANT -I/opt/jdk1.6.0_45/include -I/opt/jdk1.6.0_45/include/linux -c user.c
gcc -shared user.o -o libuser.so
```
###### Step6: 配置环境变量
```
export LD_LIBRARY_PATH=$PWD
```
###### Setp7: 运行
```
java HelloWorld
```

